相关教材：C++ 入门经典(第六版) [美]Rogers Cadenhead / Jesse Liberty著
ISBN 978-7-115-44215-4

非常好教材，使得我大脑旋转

建议是对C++的一些特性和知识有了了解后再来看这个项目，当然建议你去图书馆找一找有没有这本书，虽然翻译一般，但确实适合作为入门书籍上手，不过我也是新手就是了。
C++项目实践思路

1.	概念化：
明确我们需要实现的目标，并进行简单的拆分
如一场卡牌对战：那么我们需要有一个牌堆，有对牌堆进行混淆打乱的功能，发牌的功能，抽牌的功能，牌面的属性和对应的特性，等等……
2.	分析和需求：
明确我们的程序需要实现的具体功能，如程序的行动，一开始我们需要创建各种牌的类，然后创建一个牌堆，对牌堆进行打乱，发牌，决定先手，对手之间的交互（输出对手打出的牌，显示拥有的手牌，出牌的鉴定，胜利条件的判断），用户将与程序如何交互。

完成这两步，我们可以对程序有一个大致的认识，可以画画UML图之类的，会让我们对于程序的设计需求更加明确，后续添加其他模块和功能也更加方便和明晰。

3.	高级设计和详细设计
对于上一步我们设想的程序进行具体的实现设计，如对牌堆所有的牌提前进行创建会占用大量内存，那么我们可以先创建一个数组，进行一个简单的混淆，当发牌时再进行具体的类的创建，并在牌打出后就将该类释放掉，从而减少内存压力。设计一个记牌器，创建一个静态成员数据。
4.	其他对象
对已有的设计进行检查，确定是否需要进行其他类的创建
5.	设计类：
基类有哪些基本功能和变量，不同的类型需要实现不同的功能。在面向对象设计中，一个常见的问题就是封装，比如牌局对战时，不同牌面大小的比较，当用户想要打出手牌时，要与敌手的牌面大小进行比较，判断能否打出该手牌，那么我们最好将带判断函数封装在类里，而不是每次出牌时要额外调用函数创建新的变量再进行判断比较
6.	事件循环
事件循环通常是无限的，如while(true)，它从操作系统获取消息（鼠标单击，按键等），将其传递给相应的对象，然后继续循环，直到满足退出条件。



这里暂时不涉及类模板以及其他关于标准模板库STL的内容，因为此书出版时间较早。后面有空可能多做一些其他简单的项目实例并进行改进之类的，如果我会做的话

教材案例——PostMaster

首先，C++写软件
C/S架构

C/S也分前后端，前端(用户界面)与后端(通信与数据库部分)分开

教材决定针对windows平台进行开发，有必要再根据需要Mac OS和Linux

分而治之：略过

邮件格式：首先重点关注邮件格式，将与通信和用户界面相关的问题留到以后去处理，邮件信息，主体，正文，附件

初步类设计：
并行层次结构通常是设计糟糕的征兆。一种常见的面向对象设计的错误是，将一组对象放在一个层次结构中，将另一组对应的管理对象放在另一个层次结构中。确保这些层次结构最新且同步的工作将让设计人员不堪重负，维护难度大大增加。

同根和不同根：

继承层次结构的设计方式有两种：一是将所有类（或几乎所有类）都作为同一个根类（root class）的后代：二是使用多个继承层次结构。共用根类的优点，通常可避免多继承，缺点是很多时候需要将实现放在基类中

如果一组类有共同的祖先，就称为同根；否则称为不同根。

设计接口：
在这个阶段，不要为实现操心，应将精力放在设计清晰的接口上（写C++就要致力于压榨机器性能），再确定每个类需要哪些数据和成员函数。

在设计类之前，要对基类有深刻的了解
在这里我们重点关注pObject，pStored和pWired（这是课本的划分）
pObject：包含每个类都有的数据
pStored：对象将存储到文件
pWired：将通过网络发送

几乎所有通过网络发送的对象都必须存储，但并非所有存储的对象都必须通过网络发送，因此从pStored派生pWired是合乎逻辑的。

根类pObject只需包含系统中的每个类都有的数据和函数。可能每个对象都应有唯一的标识符，我们可能创建pID（PostMaster ID）并将其作为pObject的成员。
这又出现了另一个问题：
不需要存储和传输的对象需要这样的编号吗?
PS：课本并没有解释这种思路的，不过对软件开发了解的话仔细一想就能明白
由C++开发的C/S架构软件，我们首先需要关注不是功能的具体实现，而是框架的设计
一开始往往就是数据，存储，传输等几样。

如果没有这样的对象，应考虑将pObject和pStored合并成一个类，因为每个数据都是需要存储的。
但经过考虑后，我们应该认识到确实有一些不需要单独存储的对象（如地址），如果这些对象需要存储（地址），将其作为其他对象的一部分更好（如实现的类的指针，可以通过该指针指向它的成员函数和数据，这些当中的数据也是需要存储）
这表明，就目前而言，提供一个pObject类是有好处的。可以想见，将有一个地址簿，它包含一系列pAddress对象，虽然不会单独存储每个pAddress对象，但让它们都有唯一的标识符是有好处的。

因此，暂时将pObject设计如下：
class pObject
{
public:
	pObject();
	~pObject();
	pID GetID() const;
	void SetID();
private:
	pID itsID();
}

这个类声明有几点需要注意。首先，没有将这个类表明为从其他任何类派生而来的，它是根类。
其次，这里没有列出任何实现，虽然设计完毕后，诸如GetID()等成员函数很可能有内联实现。

第三，将成员函数声明成了const，这是接口而不是实现的一部分。最后，将pID作为一种新数据类型。通过将pID作为一种新数据类型，而不是使用内置类型，如unsigned long，提高了设计的灵活性。

在内部，pID可能使用unsigned long来表达PostMaster ID。但即便如此，前述做法也胜过在pObject类中将pID声明为unsigned long。因为如果事后证明不需要unsigned long或unsigned long不够大，可以修改pID这个新数据类型(struct)，而无需去修改每一个pID(方便了代码维护)。

 
创建原型：

对于像PostMaster这样大的项目，初步设计不太可能是完备和完美的。鉴于问题的规模如此之大，我们容易晕头转向，找不到设计的方向。因此我们要做的是，先创建所有的类并确保其接口是完整的，然后再编写代码。

原型是实现核心思想的简单示例，应使用它来验证设计。
不同类型的原型，可满足不同的需求：
如：
接口设计原型让潜在用户能够测试产品的外观。
功能原型不包含最终的用户界面，但能让用户尝试各种功能，能转发邮件和添加附件。

80/80规则

80/80规则通常指的是软件开发或项目管理中的一种经验法则，特别是在代码审查和代码提交的上下文中。虽然它不像其他更广为人知的规则那样普遍，但其含义主要可以理解为以下几种情境中的某一种：

1. **代码行和复杂度限制**：
   - 每次提交（Commit）的代码行数应不超过 **80行**，以确保每次代码变更足够小、易于审查和维护。
   - 每个函数、方法或模块的复杂度应不超过 **80行**，保持代码简单、清晰，避免过于复杂的结构。

2. **代码审查的时间和注意力分配**：
   - 每次代码审查的时间不应超过 **80分钟**，以避免审查者因过长的审查时间导致疲劳，降低审查的有效性。
   - 一次审查中单个审查者不应被分配到超过 **80%** 的工作量，留出适当的时间和精力应对其他任务或意外情况。

3. **代码风格中的列宽限制**：
   - 在某些代码风格指南中，建议每行代码不超过 **80列**，这样可以确保代码在大多数编辑器和终端中保持良好的可读性。这一点类似于 Unix/Linux 社区的一些习惯做法。

### 80/80 规则的好处：
- **提高可维护性**：通过限制代码行数和复杂度，开发人员可以创建更易于理解和维护的代码。
- **提高审查效率**：避免长时间代码审查导致的疲劳，提高审查质量。
- **代码风格一致性**：保证在各种工具和环境中，代码格式和可读性保持一致。

### 其他80相关的规则：
类似的规则还有像 **80/20法则（帕累托法则）**，其中20%的工作可以带来80%的结果，但这与80/80规则并不完全相同
